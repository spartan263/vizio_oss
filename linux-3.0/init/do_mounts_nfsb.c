/*
 * (c) 1997-2010 Netflix, Inc.  All content herein is protected by
 * U.S. copyright and other applicable intellectual property laws and
 * may not be copied without the express permission of Netflix, Inc.,
 * which reserves all rights.  Reuse of any of this content for any
 * purpose without the permission of Netflix, Inc. is strictly
 * prohibited.
 */
#include <linux/device-mapper.h>
#include <linux/nfsb.h>
#include "do_mounts.h"

static char *DEV_NFSB = "/dev/nfsb";

#if NFSB_USE_RSA2048
/* RSA-2048 modulus, big-endian. Replace with your real value. */
static uint8_t rsa_modulus[NFSB_RSAKEY_LEN] =
{
    0xb3, 0x98, 0x85, 0xb0, 0xb0, 0xb6, 0xa5, 0xe6,
    0xb3, 0x2b, 0x2a, 0x04, 0xee, 0xb0, 0x8f, 0x04,
    0x53, 0xa0, 0xa4, 0x35, 0x2f, 0xf7, 0x86, 0x0e,
    0x07, 0xbc, 0xde, 0x8b, 0x09, 0x12, 0x23, 0xc9,
    0xa8, 0xb7, 0xfd, 0xac, 0xeb, 0x35, 0x4d, 0xec,
    0xed, 0x03, 0xcd, 0x0d, 0x9e, 0x9c, 0x95, 0xbc,
    0x68, 0xf3, 0x6c, 0x1b, 0xdc, 0x37, 0xc2, 0x5c,
    0xf3, 0xe7, 0x78, 0x76, 0x2d, 0x4c, 0x4f, 0x0d,
    0x0e, 0x50, 0xaa, 0x9a, 0x67, 0xaa, 0xb8, 0x60,
    0x3e, 0xa8, 0x15, 0x0d, 0xbc, 0xc8, 0x5b, 0x23,
    0xe7, 0x1a, 0x0b, 0x74, 0x55, 0x99, 0x19, 0x4e,
    0x66, 0x54, 0x33, 0x94, 0xb0, 0x23, 0x28, 0x8d,
    0x64, 0xdd, 0x9f, 0x00, 0x78, 0x30, 0x2a, 0x92,
    0x2d, 0xd1, 0xcc, 0xab, 0x2d, 0x73, 0x0c, 0x96,
    0xba, 0xc9, 0x49, 0x15, 0xc0, 0x3f, 0x78, 0x22,
    0xec, 0xbe, 0xbe, 0x62, 0xae, 0x76, 0x59, 0x87,
    0x32, 0xbb, 0x83, 0x5e, 0xe7, 0xd9, 0x8f, 0x4b,
    0xa1, 0x18, 0x29, 0x5e, 0xcf, 0x62, 0x2e, 0xa0,
    0x2b, 0x63, 0xf0, 0x9c, 0xaf, 0x50, 0xf4, 0x6a,
    0x9a, 0x72, 0x09, 0x1c, 0x1c, 0x08, 0x5b, 0x5e,
    0x5a, 0xd3, 0x39, 0x0e, 0x12, 0xe1, 0x0c, 0xca,
    0x97, 0x6e, 0xc1, 0xab, 0x65, 0xbf, 0xca, 0x31,
    0x25, 0x44, 0x48, 0x72, 0xd4, 0x08, 0x56, 0x89,
    0xd1, 0x93, 0x1f, 0xd3, 0xd6, 0xce, 0x05, 0xdb,
    0x95, 0x0a, 0xf2, 0x42, 0x8f, 0x52, 0x29, 0xfb,
    0x4f, 0x83, 0x73, 0x81, 0x70, 0x97, 0x4e, 0x30,
    0x95, 0xa0, 0x62, 0x3a, 0xdb, 0x15, 0xb0, 0x85,
    0x7a, 0xd6, 0x12, 0x9f, 0xbe, 0x4c, 0x97, 0x4d,
    0xd4, 0xe6, 0x71, 0xaa, 0xcf, 0x77, 0xd8, 0x53,
    0xf7, 0x3a, 0x8d, 0x25, 0xa6, 0x7a, 0xec, 0x28,
    0x79, 0x53, 0xf4, 0xdf, 0x9f, 0x7b, 0xec, 0x80,
    0xf4, 0x31, 0x53, 0x18, 0xad, 0xa8, 0x70, 0x17
};

/* RSA-2048 public key exponent, big-endian. Replace with your real value. */
static uint8_t rsa_pubkey[NFSB_RSAKEY_LEN] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03
};

#else

/* RSA-1024 modulus, big-endian. Replace with your real value. */
static uint8_t rsa_modulus[NFSB_RSAKEY_LEN] =
{
    0xcb, 0xe8, 0xe4, 0xea, 0x9b, 0xa3, 0xe0, 0xc7, 
    0xca, 0x52, 0xbf, 0x40, 0x59, 0xb5, 0xe1, 0x1d, 
    0x52, 0xf4, 0x8a, 0xc3, 0x67, 0xf7, 0x2a, 0x9c, 
    0xad, 0xca, 0xa7, 0x5a, 0xa8, 0x83, 0x25, 0xde, 
    0x2f, 0xf0, 0x94, 0x80, 0x38, 0x09, 0xc5, 0xe9, 
    0xe3, 0xd8, 0xc9, 0x36, 0x1c, 0x7a, 0x98, 0xb9, 
    0x7e, 0x19, 0xd1, 0x30, 0x0b, 0x8f, 0xcf, 0x5f, 
    0xa4, 0x5b, 0xcf, 0x02, 0x55, 0x50, 0x3d, 0x08, 
    0xd4, 0x06, 0x1e, 0xb8, 0x28, 0x45, 0x88, 0xd8, 
    0x71, 0x04, 0xa7, 0x6d, 0xf9, 0xfc, 0x27, 0x98, 
    0x43, 0x5c, 0xb7, 0xad, 0xf3, 0x29, 0x73, 0x0e, 
    0x47, 0x69, 0x91, 0x85, 0xd6, 0x8e, 0x43, 0xc9, 
    0x78, 0xe6, 0x8a, 0x47, 0x64, 0x43, 0xb3, 0x5e,
    0x05, 0x5b, 0x39, 0xca, 0x58, 0xca, 0x8d, 0x21, 
    0x0a, 0x4f, 0x74, 0xbe, 0xc1, 0x8a, 0x38, 0x19, 
    0xbc, 0x3e, 0xe8, 0x7c, 0xd8, 0x41, 0x7c, 0x9b
};

/* RSA-1024 public key exponent, big-endian. Replace with your real value. */
static uint8_t rsa_pubkey[NFSB_RSAKEY_LEN] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03
};
#endif

// Called in kernel space for non-rootfs image
int dm_check_nonroot_nfsb(struct nfsb_header *hdr, char *devname)
{
	ssize_t sz = -1;
	mm_segment_t oldfs;
	struct file *fp;
	mpuint *pubkey = NULL, *modulus = NULL;

	// Bypass memory boundary check when set KERNEL_DS.
	oldfs = get_fs();
	set_fs(KERNEL_DS);

	/* Try to read an NFSB header from the root device. */
	fp = filp_open(devname, O_RDONLY, 0);
	if (!fp) {
		printk(KERN_ERR "nfsb: open %s failed\n", devname);
		goto open_fail;
	}
	
	sz = nfsb_nonroot_read(fp, hdr);
	if (sz == -1)
	{
		printk(KERN_ERR "nfsb: check %s header fail\n", devname);
		goto read_fail;
	}

	/* Verify the NFSB header. */
	pubkey = mpuint_alloc(sizeof(rsa_pubkey));
	if (!pubkey) {
		printk(KERN_ERR "out of memory\n");
		goto pubkey_fail;
	}
	
	pubkey = mpuint_setbytes(pubkey, rsa_pubkey, sizeof(rsa_pubkey));
	if (!pubkey) {
		printk(KERN_ERR "mpuint_setbytes failed\n");
		goto pubkey_fail;
	}
	
	modulus = mpuint_alloc(sizeof(rsa_modulus));
	if (!modulus) {
		printk(KERN_ERR "out of memory\n");
		goto modulus_fail;
	}

	modulus = mpuint_setbytes(modulus, rsa_modulus, sizeof(rsa_modulus));
	if (!modulus) {
		printk(KERN_ERR "mpuint_setbytes failed\n");
		goto modulus_fail;
	}
	
	if (nfsb_verify(hdr, pubkey, modulus) != 0) {
		printk(KERN_ERR "nfsb: header verification failed\n");
		goto verify_fail;
	}
	
	printk(KERN_INFO "%s: NFSB header found and verified.\n", devname);

	/* Success. */
	mpuint_delete(modulus);
	mpuint_delete(pubkey);
	filp_close(fp, NULL);
	set_fs(oldfs);
	return 1;

verify_fail:
modulus_fail:
	mpuint_delete(modulus);
pubkey_fail:
	mpuint_delete(pubkey);
read_fail:
	filp_close(fp, NULL);
open_fail:
	set_fs(oldfs);
	return 0;
}

// Called in user space for rootfs image
static int __init dm_check_nfsb(struct nfsb_header *hdr, dev_t dev)
{
	int err = 0;
	int root_fd = -1;
	ssize_t sz = -1;
	mpuint *pubkey = NULL, *modulus = NULL;

	/* Create a temporary root device. */
	err = create_dev(DEV_NFSB, dev);
	if (err < 0) {
		printk(KERN_ERR "nfsb: create_dev failed\n");
		goto create_fail;
	}
	
	/* Try to read an NFSB header from the root device. */
	root_fd = sys_open(DEV_NFSB, O_RDONLY, 0);
	if (root_fd < 0) {
		printk(KERN_ERR "nfsb: open %s failed\n", DEV_NFSB);
		goto open_fail;
	}
	
	sz = nfsb_read(root_fd, hdr);
	if (sz == -1)
	{
		printk(KERN_ERR "nfsb: check %s header fail\n", DEV_NFSB);
		goto read_fail;
	}

	/* Verify the NFSB header. */
	pubkey = mpuint_alloc(sizeof(rsa_pubkey));
	if (!pubkey) {
		printk(KERN_ERR "out of memory\n");
		goto pubkey_fail;
	}
	
	pubkey = mpuint_setbytes(pubkey, rsa_pubkey, sizeof(rsa_pubkey));
	if (!pubkey) {
		printk(KERN_ERR "mpuint_setbytes failed\n");
		goto pubkey_fail;
	}
	
	modulus = mpuint_alloc(sizeof(rsa_modulus));
	if (!modulus) {
		printk(KERN_ERR "out of memory\n");
		goto modulus_fail;
	}
	
	modulus = mpuint_setbytes(modulus, rsa_modulus, sizeof(rsa_modulus));
	if (!modulus) {
		printk(KERN_ERR "mpuint_setbytes failed\n");
		goto modulus_fail;
	}
	
	if (nfsb_verify(hdr, pubkey, modulus) != 0) {
		printk(KERN_ERR "nfsb: header verification failed\n");
		goto verify_fail;
	}
	
	printk(KERN_INFO "%s: NFSB header found and verified.\n", DEV_NFSB);

	/* Success. */
	mpuint_delete(modulus);
	mpuint_delete(pubkey);
	sys_close(root_fd);
	return 1;

verify_fail:
modulus_fail:
	mpuint_delete(modulus);
pubkey_fail:
	mpuint_delete(pubkey);
read_fail:
	sys_close(root_fd);
open_fail:
	sys_unlink(DEV_NFSB);
create_fail:
	return 0;
}

/* From drivers/md/dm.h */
#define DM_SUSPEND_NOFLUSH_FLAG         (1 << 1)
#define DM_NFSB_MINOR                   (0)

static dev_t __init dm_setup_nfsb(struct nfsb_header *hdr, dev_t dev)
{
	struct mapped_device *md = NULL;
	struct dm_table *table = NULL;
	char *target_params = NULL;
	ssize_t fs_offset = to_sector(nfsb_fs_offset(hdr));
	ssize_t fs_size = to_sector(nfsb_fs_size(hdr));
	
	/* Create a new mapped device. */
	if (dm_create(DM_NFSB_MINOR, &md)) {
		printk(KERN_ERR "Failed to create mapped device\n");
		goto dm_create_fail;
	}

	/* Explicitly set read-only. */
	set_disk_ro(dm_disk(md), 1);

	/* Create a mapped device table. */
	if (dm_table_create(&table, FMODE_READ, 1, md)) {
		printk(KERN_ERR "Failed to create table\n");
		goto table_create_fail;
	}

	/* Add the NFSB verity target to the table. */
	target_params = kmalloc(256, GFP_KERNEL);
	snprintf(target_params, 256, "%s %u %s %u %u %s %u %s",
			 DEV_NFSB, fs_offset, DEV_NFSB, fs_offset + fs_size,
			 nfsb_hash_depth(hdr), nfsb_hash_algo(hdr),
			 nfsb_hash_sectors(hdr), nfsb_verity_hash(hdr));
	if (dm_table_add_target(table, "verity", 0, fs_size, target_params)) {
		printk(KERN_ERR "Failed to add NFSB target to the table\n");
		goto add_target_fail;
	}

	/* Table is complete. */
	if (dm_table_complete(table)) {
		printk(KERN_ERR "Failed to complete NFSB table\n");
		goto failure;
	}

	/* Suspend the device so that we can bind it to the table. */
	if (dm_suspend(md, DM_SUSPEND_NOFLUSH_FLAG)) {
		printk(KERN_ERR "Failed to suspend the device pre-bind\n");
		goto failure;
	}

	/* Bind the table to the device. This is the only way to associated
	 * md->map with the table and set the disk capacity. Ouch. */
	if (dm_swap_table(md, table)) {
		printk(KERN_ERR "Failed to bind the device to the table\n");
		goto failure;
	}
	
	/* Finally, resume and the device should be ready. */
	if (dm_resume(md)) {
		printk(KERN_ERR "Failed to resume the device\n");
		goto failure;
	}

	/* Success. */
	dev = disk_devt(dm_disk(md));
	printk(KERN_INFO "dm: target '%s' of size %llu on %s(%i:%i) is ready\n",
		   target_params, dm_table_get_size(table), dm_device_name(md),
		   MAJOR(dev), MINOR(dev));
	return dev;

failure:
add_target_fail:
	dm_table_put(table);
table_create_fail:
	dm_put(md);
dm_create_fail:
	kfree(target_params);
	return dev;
}

dev_t __init dm_mount_nfsb(dev_t dev)
{
	struct nfsb_header *hdr = NULL;

	hdr = kmalloc(sizeof(struct nfsb_header), GFP_KERNEL);
	if (!hdr)
		panic("Failed to allocate NFSB header struct.");

	printk(KERN_INFO "Checking for NFSB mount.\n");
	if (!dm_check_nfsb(hdr, dev))
		panic("No NFSB image found.");
	dev = dm_setup_nfsb(hdr, dev);

	kfree(hdr);
	return dev;
}
